# 思路

假设p=6，q=7，树如题目

后序遍历中 6->7->5（最新祖先） ===》 “最近”需要后序遍历

## 函数定义

一般：返回两个节点的最近祖先 分情况讨论：因为递归中 每种情况都会出现

* 如果p，q在root左右两边：祖先就是root，后序遍历左右根，【第一个走到的符合条件的根，就是最近的、
* 以root为根的树里只有一个节点q\p，那就返回q或者p，因为每个节点可以是自己的祖先（相当于q和null的公共祖先，null的祖先可以是任何人，那最近公共祖先就是q\p）
* 以root为根的树里一个节点都没有，返回null。显然。没有祖先。
* 以root为根的树里两个节点都有，返回“符合题意”的最近公共祖先

## 状态

这题不需要其他状态参数，root，q，p就可以了

## 获得递归结果后怎么做选择

假如获得了 recursion(root.left,q,p) 和recursion(root.right,q,p)的结果，怎么处理当前节点root的逻辑：

根据【函数定义】，recursion可能的返回值是：q\p，公共祖先，null。其中qp和返回祖先统一为“函数返回了有效祖先”这个情况

再看leftRecursion和rightRecursion分别的返回值：一共是“返回祖先”和null的4种排列

* left返回组先+right返回祖先 = 那到底哪一个祖先才是真正的最近公共祖先呢？都不是，只能是root本身。
* left返回祖先+right返回null = 说明right子树中qp都没有，首先root肯定不是两个节点的祖先，所以那肯定是以left返回的祖先为准，向上一级返回left返回的祖先
* left返回null+right返回left = 同上
* left返回null+right返回null = 两边都没有目标，那root啥也不是，向上返回null

## 边界情况

虽然不属于3要素，但是边界条件很重要

由于会递归访问left和right，所以 判空返回null 的边界是必须的

"想到函数定义里第一条还没有逻辑实现" ==》 如果root本身就是p或者q，比如说root就是p节点吧，如果q存在于以root为根的树中，显然root就是最近公共祖先；即使q不存在于以root为根的树中，按照情况 3
的定义，也应该返回root节点。 ==》 if root == p or q的情况 直接返回root 【这里很重要】

