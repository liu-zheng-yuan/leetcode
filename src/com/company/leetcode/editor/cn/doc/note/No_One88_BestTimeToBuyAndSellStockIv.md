* 状态：第几天i，剩余最多的交易次数k，手里有没有股票 rest（true、false）
* 选择：买入、卖出、无操作hold （具体可用操作跟状态有关，比如不持有股票就不能卖）
* 如何遍历状态与选择：


    dp[i][k][0 or 1]
    0 <= i <= n - 1, 1 <= k <= K
    n 为天数，大 K 为交易数的上限，0 和 1 代表是否持有股票。
    此问题共 n × K × 2 种状态，全部穷举就能搞定。
    
    for 0 <= i < n:
      for 1 <= k <= K:
        for s in {0, 1}:
          dp[i][k][s] = max(buy, sell, rest)

* 定义：dp[i][k][hold = 0 or 1]表示当前第i天，最多交易k次，手里有、无股票的情况下，能获得的最大收益。
* 边界条件：1.i = -1时，不管可以交易多少次，收益都是0 （这时hold = 1的情况没有意义，为了取最大值方便，赋值-infinity） 2.k = 0时，不管在第几天，因为不允许交易也都没有收益。（注意 i =-1和i=0不一样，i=0其实是第一天，已经可以买卖股票了）
* 转移方程：
    * 选择“买入”：dp[i][k][1] = dp[i-1][k-1][0] - prices[i] dp[i][k][0] 无意义。意思是：如果当天选择买入，当天会消耗一次交易机会，反推之前状态所剩下的交易次数就要-1，且之前状态是手上没有股票的（不允许不卖就买）
    * 选择“卖出“：dp[i][k][0] = dp[i-1][k][1] + prices[i] dp[i][k][1] 无意义。买入才需要花费交易机会，卖出不算！之前状态需要手上有股票
    * 选择“无操作”：dp[i][k][0] = dp[i-1][k][0]  dp[i][k][1] = dp[i-1][k][1]。意思是：继承前一天的状态
    * 所以：dp[i][k][0] = max(dp[i-1][k][1] + prices[i],dp[i-1][k][0]) dp[i][k][1] = max(dp[i-1][k-1][0] - prices[i], dp[i-1][k][1])