思路：因为数字都在0-n-1之间，数组长度只有n，且有若干个多出来的。假设每个数字都按正确的位置i=num[I]排排坐，那么重复的数字肯定有“多个同样的数字占据了同一个位置的情况”。
我们的算法就是为了找到这种情况，先遍历i，把已经遍历到的num[I]都排到正确的座位上，如果遍历到正确的座位上有人的情况，那肯定是重复的那个。

遍历num ，对每个i：

* 查看num[i]是不是在“应该在的位置上”，即i=num[i]
* 如果是，继续
* 如果不是，将num[i]放置到它“应该在的位置”即放置到num[num[i]]上，将原来num[num[i]]里的数字放到i上。即对调
    * 如果对调时，发现它应该在的位置上已经有“正确的数字”了，说明找到重复的数字了。即，i！=num[i] && num[num[i]] = num[i]