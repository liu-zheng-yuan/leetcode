## 思路

本质上就是对每一个格子穷举1-9，最坏复杂度 9^（n*m），其中有一些小技巧需要学习

* 遍历二维数组：添加辅助参数row，col；每次col++，当col = colMax，转为row++ ==》相当于原本遍历的是 “本行的决策子树” 然后跳到“下一行的决策子树”
* 跳过有数的格子：边界条件里判断“如果有数”，跳到下一个col++的决策子树 ==》 其实也相当于“在当前节点的情况下，如何做决策”，只不过这里没有for循环做选择，而是直接确定下一个递归是啥
* 判断是否可以填入n：1.枚举这一行每个一个数是否等于n 2，枚举这一列每一个数是否等于n 3，枚举周围3*3方框是否等于n

      for (int i = 0; i < 9; i++) {
      // 判断行是否存在重复
      if (board[r][i] == n) return false;
      // 判断列是否存在重复
      if (board[i][c] == n) return false;
      // 判断 3 x 3 方框是否存在重复
      if (board[(r/3)*3 + i/3][(c/3)*3 + i%3] == n)
      return false;
      }
      return true;